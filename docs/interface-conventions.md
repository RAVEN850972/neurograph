# Соглашение об интерфейсах и абстрактных классах NeuroGraph

## 1. Основные принципы

### 1.1. Общие положения

1. Весь функционал системы NeuroGraph должен быть доступен через четко определенные интерфейсы и абстрактные классы.
2. Конкретные реализации должны наследоваться от абстрактных классов или реализовывать интерфейсы.
3. Модули должны зависеть от интерфейсов, а не от конкретных реализаций (принцип инверсии зависимостей).
4. Изменения в интерфейсах должны управляться через формальный процесс и минимизироваться.
5. Дополнительный функционал должен добавляться через расширение, а не модификацию (принцип открытости/закрытости).
6. Каждый интерфейс должен быть сфокусирован на одной конкретной ответственности (принцип единственной ответственности).

### 1.2. Жизненный цикл интерфейсов

1. **Проектирование**: Определение функциональности, методов, типов данных.
2. **Ревью**: Проверка интерфейса на соответствие принципам дизайна и требованиям системы.
3. **Реализация**: Создание одной или нескольких конкретных реализаций.
4. **Тестирование**: Проверка реализаций на соответствие контрактам интерфейса.
5. **Документирование**: Подробное описание интерфейса, его методов и контрактов.
6. **Поддержка**: Управление изменениями и версиями интерфейса.

### 1.3. Версионирование интерфейсов

1. Для интерфейсов применяется семантическое версионирование (MAJOR.MINOR.PATCH).
2. Увеличение MAJOR версии происходит при несовместимых изменениях API.
3. Увеличение MINOR версии происходит при добавлении новой функциональности с сохранением обратной совместимости.
4. Увеличение PATCH версии происходит при исправлении ошибок с сохранением обратной совместимости.
5. Устаревшие (deprecated) методы и интерфейсы должны быть явно помечены и сохраняться не менее одного цикла MAJOR версии.
6. Каждое изменение интерфейса должно быть задокументировано в истории изменений (CHANGELOG).

## 2. Структура и именование

### 2.1. Структура файлов

1. Каждый модуль должен содержать файл `base.py` с определениями интерфейсов и абстрактных классов.
2. Конкретные реализации должны располагаться в директории `impl/`.
3. Утилиты и вспомогательные классы должны располагаться в директории `utils/`.
4. Примеры использования должны располагаться в директории `examples/`.
5. Тесты должны располагаться в директории `tests/`.

Пример:
```
memory/
├── __init__.py          # Экспортирует основной API
├── base.py              # Интерфейсы и абстрактные классы
├── impl/                # Конкретные реализации
│   ├── __init__.py
│   ├── vector_memory.py
│   └── biomorphic.py
├── utils/               # Утилиты
├── examples/            # Примеры использования
└── tests/               # Тесты
```

### 2.2. Именование интерфейсов и классов

1. **Интерфейсы** должны начинаться с "I" для явного обозначения (например, `IMemory`).
2. **Абстрактные классы** должны иметь префикс "Abstract" или суффикс "Base" (например, `AbstractMemory` или `MemoryBase`).
3. **Конкретные реализации** должны иметь описательные имена, указывающие на их специфику (например, `BiomorphicMemory`).
4. **Фабрики** должны иметь суффикс "Factory" (например, `MemoryFactory`).
5. **Регистры** должны иметь суффикс "Registry" (например, `MemoryRegistry`).

### 2.3. Именование методов

1. **Геттеры**: начинаются с `get_` (например, `get_node()`).
2. **Сеттеры**: начинаются с `set_` (например, `set_weight()`).
3. **Булевы методы**: начинаются с `is_`, `has_`, `can_` (например, `is_valid()`, `has_node()`, `can_process()`).
4. **Методы действия**: используют глаголы (например, `add_node()`, `remove_edge()`, `process_text()`).
5. **Фабричные методы**: начинаются с `create_` (например, `create_memory()`).
6. **Методы преобразования**: используют формат `to_<format>` (например, `to_dict()`, `to_json()`).

### 2.4. Структура интерфейсов

1. Интерфейсы должны быть минимальными и сфокусированными на одной ответственности.
2. Сложные интерфейсы должны разбиваться на более простые (принцип разделения интерфейса).
3. Методы должны быть сгруппированы логически и разделены комментариями.
4. Интерфейсы должны иметь четко определенные входные и выходные типы данных.

## 3. Документирование интерфейсов

### 3.1. Общие требования к документации

1. Каждый интерфейс должен иметь подробное описание своего назначения и контекста использования.
2. Каждый метод должен иметь документацию с описанием, параметрами, возвращаемыми значениями и исключениями.
3. Должны быть указаны пред- и постусловия для методов.
4. Документация должна соответствовать реальному поведению интерфейса.

### 3.2. Формат документации

Все интерфейсы и методы должны быть документированы в формате Google Style:

```python
class IMemory(ABC):
    """Интерфейс для системы памяти.
    
    Этот интерфейс определяет методы для работы с системой памяти,
    включая добавление, поиск и удаление элементов.
    
    Attributes:
        capacity: Максимальная емкость памяти.
        item_count: Текущее количество элементов в памяти.
    """
    
    @abstractmethod
    def add(self, item: MemoryItem) -> str:
        """Добавляет элемент в память и возвращает его ID.
        
        Args:
            item: Элемент для добавления в память.
            
        Returns:
            Уникальный идентификатор добавленного элемента.
            
        Raises:
            MemoryFullError: Если память заполнена и не может принять новый элемент.
            InvalidItemError: Если элемент не соответствует требуемому формату.
            
        Note:
            Этот метод должен быть потокобезопасным.
        """
        pass
```

### 3.3. Контракты методов

Для каждого метода должны быть определены контракты:

1. **Предусловия**: условия, которые должны быть выполнены перед вызовом метода.
2. **Постусловия**: условия, которые будут выполнены после успешного завершения метода.
3. **Инварианты**: условия, которые всегда должны быть истинны для объекта.
4. **Исключения**: условия, при которых метод может выбросить исключение.

Пример:
```python
@abstractmethod
def add_edge(self, source: str, target: str, edge_type: str = "default", 
             weight: float = 1.0, **attributes) -> None:
    """Добавляет направленное ребро между узлами.
    
    Предусловия:
        - source и target должны быть непустыми строками
        - weight должен быть положительным числом
        
    Постусловия:
        - Ребро будет добавлено в граф
        - Если указанные узлы не существуют, они будут созданы
        - get_edge(source, target, edge_type) вернет ребро с указанными атрибутами
        
    Исключения:
        - InvalidNodeError: Если source или target имеют недопустимый формат
        - InvalidWeightError: Если weight имеет недопустимое значение
    
    Args:
        source: ID исходного узла.
        target: ID целевого узла.
        edge_type: Тип ребра.
        weight: Вес ребра.
        **attributes: Дополнительные атрибуты ребра.
    """
    pass
```

## 4. Типизация и проверка типов

### 4.1. Использование type hints

1. Все публичные методы и функции должны иметь полные аннотации типов.
2. Приватные методы должны иметь аннотации типов, если это улучшает понимание кода.
3. Следует использовать типы из модуля typing (List, Dict, Optional, Union и т.д.).
4. Для сложных типов следует использовать TypeVar и Generic.
5. Для улучшения читаемости сложных типов следует использовать псевдонимы типов (type aliases).

```python
from typing import Dict, List, Optional, Union, TypeVar, Generic

T = TypeVar('T')
NodeID = str
EdgeType = str
Weight = float
Attributes = Dict[str, Any]

class IGraph(Generic[T]):
    @abstractmethod
    def add_node(self, node_id: NodeID, **attributes: Any) -> None:
        pass
        
    @abstractmethod
    def get_neighbors(self, node_id: NodeID, 
                      edge_type: Optional[EdgeType] = None) -> List[NodeID]:
        pass
```

### 4.2. Валидация типов

1. Статическая проверка типов должна выполняться с помощью mypy или аналогичных инструментов.
2. Для критических методов рекомендуется дополнительная динамическая проверка типов.
3. Проверка типов должна быть включена в CI/CD процесс.

### 4.3. Взаимодействие с динамической типизацией

1. Следует учитывать возможность использования кода с отключенной проверкой типов.
2. Критически важные проверки типов должны дублироваться в рантайме.
3. Документация должна явно указывать, где ожидаются определенные типы.

## 5. Расширение интерфейсов

### 5.1. Добавление новых методов

1. Новые методы должны добавляться через механизм расширения интерфейсов.
2. При необходимости добавления нового метода в существующий интерфейс следует:
   a. Создать новый расширяющий интерфейс
   b. Обеспечить обратную совместимость
   c. Обновить документацию

```python
class IMemory(ABC):
    @abstractmethod
    def add(self, item: MemoryItem) -> str:
        pass
        
    @abstractmethod
    def get(self, item_id: str) -> Optional[MemoryItem]:
        pass

# Расширение интерфейса
class IAdvancedMemory(IMemory):
    @abstractmethod
    def bulk_add(self, items: List[MemoryItem]) -> List[str]:
        pass
```

### 5.2. Обеспечение обратной совместимости

1. Изменения в параметрах методов должны быть обратно совместимыми.
2. Новые обязательные параметры должны иметь значения по умолчанию.
3. Порядок параметров не должен меняться в существующих методах.
4. Возвращаемые типы могут быть расширены, но не сужены.

```python
# Оригинальный метод
@abstractmethod
def search(self, query: str, limit: int = 10) -> List[Result]:
    pass

# Правильное расширение (обратно совместимое)
@abstractmethod
def search(self, query: str, limit: int = 10, 
           filters: Optional[Dict[str, Any]] = None) -> List[Result]:
    pass

# Неправильное расширение (не совместимо)
@abstractmethod
def search(self, filters: Dict[str, Any], query: str, 
           limit: int = 10) -> List[Result]:
    pass
```

### 5.3. Устаревание (Deprecation)

1. Устаревшие методы должны быть явно помечены с помощью декоратора `@deprecated`.
2. Документация устаревших методов должна указывать альтернативу.
3. Устаревшие методы должны генерировать предупреждение при использовании.
4. Устаревшие методы должны поддерживаться не менее одного цикла MAJOR версии.

```python
from warnings import warn

def deprecated(message: str):
    """Декоратор для пометки устаревших методов."""
    def decorator(func):
        def wrapper(*args, **kwargs):
            warn(f"{func.__name__} is deprecated: {message}", 
                 DeprecationWarning, stacklevel=2)
            return func(*args, **kwargs)
        return wrapper
    return decorator

class IMemory(ABC):
    @abstractmethod
    @deprecated("Use 'search' method instead")
    def find(self, query: str) -> List[MemoryItem]:
        """Устаревший метод для поиска элементов.
        
        Deprecated:
            Этот метод устарел и будет удален в версии 2.0.0.
            Используйте метод 'search' вместо него.
        """
        pass
        
    @abstractmethod
    def search(self, query: str, limit: int = 10) -> List[MemoryItem]:
        """Ищет элементы, соответствующие запросу."""
        pass
```

## 6. Реализация интерфейсов

### 6.1. Абстрактные базовые классы

1. Рекомендуется использовать абстрактные базовые классы (ABC) для общего кода.
2. Абстрактные базовые классы должны реализовывать общую логику и оставлять специфичную функциональность для подклассов.
3. Абстрактные методы должны иметь подробную документацию, указывающую, что должны делать реализации.

```python
class MemoryBase(IMemory, ABC):
    """Базовый класс для реализаций памяти.
    
    Этот класс реализует общую логику и оставляет специфическую
    функциональность для подклассов.
    """
    
    def __init__(self, capacity: int = 1000):
        self.capacity = capacity
        self._items: Dict[str, MemoryItem] = {}
        
    @abstractmethod
    def _store_item(self, item: MemoryItem, item_id: str) -> None:
        """Сохраняет элемент в конкретном хранилище.
        
        Этот метод должен быть реализован подклассами.
        """
        pass
        
    def add(self, item: MemoryItem) -> str:
        """Добавляет элемент в память и возвращает его ID."""
        if len(self._items) >= self.capacity:
            raise MemoryFullError("Memory is full")
            
        item_id = str(uuid.uuid4())
        self._store_item(item, item_id)
        self._items[item_id] = item
        return item_id
```

### 6.2. Проверка соответствия интерфейсу

1. Реализации должны строго соответствовать контрактам интерфейса.
2. Реализации должны соблюдать все пред- и постусловия, указанные в интерфейсе.
3. Реализации должны генерировать только те исключения, которые указаны в интерфейсе, или их подклассы.
4. Для проверки соответствия реализации интерфейсу рекомендуется использовать протокольное тестирование.

```python
def test_memory_implementation_conforms_to_interface(memory_impl: IMemory):
    """Проверяет, что реализация соответствует интерфейсу IMemory."""
    # Тест на add
    item = MemoryItem(content="test", embedding=np.array([0.1, 0.2]))
    item_id = memory_impl.add(item)
    assert isinstance(item_id, str)
    
    # Тест на get
    retrieved_item = memory_impl.get(item_id)
    assert retrieved_item is not None
    assert retrieved_item.content == "test"
    
    # Тест на get с несуществующим ID
    non_existent_id = "non_existent_id"
    assert memory_impl.get(non_existent_id) is None
    
    # И так далее для всех методов интерфейса
```

### 6.3. Фабрики и регистры

1. Для создания и управления реализациями следует использовать фабрики и регистры.
2. Фабрики должны скрывать детали создания объектов и предоставлять удобный API.
3. Регистры должны позволять динамическую регистрацию и поиск реализаций.

```python
class MemoryFactory:
    """Фабрика для создания экземпляров IMemory."""
    
    @staticmethod
    def create(memory_type: str = "vector", **kwargs) -> IMemory:
        """Создает экземпляр памяти указанного типа.
        
        Args:
            memory_type: Тип памяти ("vector", "biomorphic", и т.д.).
            **kwargs: Параметры для конструктора памяти.
            
        Returns:
            Экземпляр IMemory.
            
        Raises:
            ValueError: Если указан неизвестный тип памяти.
        """
        registry = memory_registry.get_registry()
        
        if memory_type not in registry:
            raise ValueError(f"Unknown memory type: {memory_type}")
            
        memory_class = registry[memory_type]
        return memory_class(**kwargs)
```

## 7. Тестирование интерфейсов

### 7.1. Тестирование контрактов

1. Для каждого интерфейса должен быть создан набор тестов, проверяющих соответствие контрактам.
2. Тесты должны проверять:
   - Предусловия
   - Постусловия
   - Инварианты
   - Обработку исключений

```python
class TestMemoryInterface:
    """Тесты для проверки соответствия интерфейсу IMemory."""
    
    def test_add_returns_string_id(self, memory: IMemory):
        """Проверяет, что add возвращает строковый ID."""
        item = MemoryItem(content="test", embedding=np.array([0.1, 0.2]))
        item_id = memory.add(item)
        assert isinstance(item_id, str)
        
    def test_add_invalid_item_raises_error(self, memory: IMemory):
        """Проверяет, что add генерирует исключение при недопустимом элементе."""
        with pytest.raises(InvalidItemError):
            memory.add(None)  # type: ignore
            
    # И так далее для всех методов
```

### 7.2. Тестирование с использованием заглушек

1. Для тестирования кода, использующего интерфейсы, следует создавать заглушки (stubs) и моки (mocks).
2. Заглушки должны имитировать поведение реальных реализаций для целей тестирования.
3. Заглушки должны быть простыми и предсказуемыми.

```python
class MemoryStub(IMemory):
    """Заглушка для тестирования IMemory."""
    
    def __init__(self):
        self._items: Dict[str, MemoryItem] = {}
        
    def add(self, item: MemoryItem) -> str:
        item_id = str(uuid.uuid4())
        self._items[item_id] = item
        return item_id
        
    def get(self, item_id: str) -> Optional[MemoryItem]:
        return self._items.get(item_id)
        
    def search(self, query: Union[str, np.ndarray], limit: int = 10) -> List[Tuple[str, float]]:
        # Простая реализация для тестирования
        return [(id, 1.0) for id in list(self._items.keys())[:limit]]
```

### 7.3. Тестирование взаимодействия

1. Для тестирования взаимодействия между компонентами следует использовать интеграционные тесты.
2. Интеграционные тесты должны проверять корректность взаимодействия компонентов через их интерфейсы.
3. Для сложных взаимодействий рекомендуется использовать моки с записью и проверкой вызовов.

```python
def test_processor_uses_memory_correctly(self):
    """Проверяет правильность взаимодействия процессора с памятью."""
    # Создаем мок памяти
    memory_mock = MagicMock(spec=IMemory)
    
    # Настраиваем поведение мока
    memory_mock.search.return_value = [("1", 0.9), ("2", 0.8)]
    
    # Создаем процессор с моком памяти
    processor = Processor(memory=memory_mock)
    
    # Выполняем операцию, использующую память
    processor.query("test query")
    
    # Проверяем, что метод памяти был вызван правильно
    memory_mock.search.assert_called_once_with("test query", limit=10)
```

## 8. Примеры интерфейсов

### 8.1. Пример интерфейса IMemory

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Union
import numpy as np
import uuid

class MemoryItem:
    """Элемент памяти с контентом и векторным представлением."""
    
    def __init__(self, content: str, embedding: np.ndarray, 
                 content_type: str = "text", metadata: Optional[Dict[str, Any]] = None):
        self.content = content
        self.embedding = embedding
        self.content_type = content_type
        self.metadata = metadata or {}
        self.id: Optional[str] = None

class IMemory(ABC):
    """Интерфейс для системы памяти.
    
    Этот интерфейс определяет методы для работы с системой памяти,
    включая добавление, поиск и удаление элементов.
    
    Версия: 1.0.0
    """
    
    @abstractmethod
    def add(self, item: MemoryItem) -> str:
        """Добавляет элемент в память и возвращает его ID.
        
        Args:
            item: Элемент для добавления в память.
            
        Returns:
            Уникальный идентификатор добавленного элемента.
            
        Raises:
            MemoryFullError: Если память заполнена и не может принять новый элемент.
            InvalidItemError: Если элемент не соответствует требуемому формату.
        """
        pass
        
    @abstractmethod
    def get(self, item_id: str) -> Optional[MemoryItem]:
        """Возвращает элемент памяти по ID.
        
        Args:
            item_id: Идентификатор элемента.
            
        Returns:
            Элемент памяти или None, если элемент не найден.
        """
        pass
        
    @abstractmethod
    def search(self, query: Union[str, np.ndarray], limit: int = 10) -> List[Tuple[str, float]]:
        """Ищет элементы, похожие на запрос.
        
        Args:
            query: Текстовый запрос или векторное представление.
            limit: Максимальное количество результатов.
            
        Returns:
            Список кортежей (id, score), где score - мера сходства.
        """
        pass
        
    @abstractmethod
    def update(self, item_id: str, **attributes) -> bool:
        """Обновляет атрибуты элемента памяти.
        
        Args:
            item_id: Идентификатор элемента.
            **attributes: Атрибуты для обновления.
            
        Returns:
            True, если элемент был обновлен, иначе False.
        """
        pass
        
    @abstractmethod
    def remove(self, item_id: str) -> bool:
        """Удаляет элемент из памяти.
        
        Args:
            item_id: Идентификатор элемента.
            
        Returns:
            True, если элемент был удален, иначе False.
        """
        pass
        
    @abstractmethod
    def clear(self) -> None:
        """Очищает память."""
        pass
        
    @abstractmethod
    def size(self) -> int:
        """Возвращает размер памяти (количество элементов).
        
        Returns:
            Количество элементов в памяти.
        """
        pass
```

### 8.2. Пример интерфейса ISemGraph

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Tuple, Any, Optional

class ISemGraph(ABC):
    """Интерфейс семантического графа.
    
    Этот интерфейс определяет методы для работы с семантическим графом,
    включая добавление узлов и ребер, поиск и обход графа.
    
    Версия: 1.0.0
    """
    
    @abstractmethod
    def add_node(self, node_id: str, **attributes) -> None:
        """Добавляет узел в граф с заданными атрибутами.
        
        Args:
            node_id: Идентификатор узла.
            **attributes: Атрибуты узла.
        """
        pass
        
    @abstractmethod
    def add_edge(self, source: str, target: str, edge_type: str = "default", 
                weight: float = 1.0, **attributes) -> None:
        """Добавляет направленное ребро между узлами.
        
        Args:
            source: Идентификатор исходного узла.
            target: Идентификатор целевого узла.
            edge_type: Тип ребра.
            weight: Вес ребра.
            **attributes: Атрибуты ребра.
        """
        pass
        
    @abstractmethod
    def get_node(self, node_id: str) -> Dict[str, Any]:
        """Возвращает узел с его атрибутами.
        
        Args:
            node_id: Идентификатор узла.
            
        Returns:
            Словарь атрибутов узла.
            
        Raises:
            KeyError: Если узел не найден.
        """
        pass
        
    @abstractmethod
    def get_edge(self, source: str, target: str, edge_type: str = "default") -> Dict[str, Any]:
        """Возвращает ребро с его атрибутами.
        
        Args:
            source: Идентификатор исходного узла.
            target: Идентификатор целевого узла.
            edge_type: Тип ребра.
            
        Returns:
            Словарь атрибутов ребра.
            
        Raises:
            KeyError: Если ребро не найдено.
        """
        pass
        
    @abstractmethod
    def get_neighbors(self, node_id: str, edge_type: Optional[str] = None) -> List[str]:
        """Возвращает соседей узла.
        
        Args:
            node_id: Идентификатор узла.
            edge_type: Тип ребра для фильтрации (если None, возвращаются все соседи).
            
        Returns:
            Список идентификаторов соседних узлов.
        """
        pass
        
    @abstractmethod
    def get_predecessors(self, node_id: str, edge_type: Optional[str] = None) -> List[str]:
        """Возвращает предшественников узла.
        
        Args:
            node_id: Идентификатор узла.
            edge_type: Тип ребра для фильтрации (если None, возвращаются все предшественники).
            
        Returns:
            Список идентификаторов узлов-предшественников.
        """
        pass
        
    @abstractmethod
    def get_edge_weight(self, source: str, target: str, edge_type: str = "default") -> float:
        """Возвращает вес ребра.
        
        Args:
            source: Идентификатор исходного узла.
            target: Идентификатор целевого узла.
            edge_type: Тип ребра.
            
        Returns:
            Вес ребра.
            
        Raises:
            KeyError: Если ребро не найдено.
        """
        pass
        
    @abstractmethod
    def update_edge_weight(self, source: str, target: str, weight: float, 
                        edge_type: str = "default") -> None:
        """Обновляет вес ребра.
        
        Args:
            source: Идентификатор исходного узла.
            target: Идентификатор целевого узла.
            weight: Новый вес ребра.
            edge_type: Тип ребра.
            
        Raises:
            KeyError: Если ребро не найдено.
        """
        pass
        
    @abstractmethod
    def has_node(self, node_id: str) -> bool:
        """Проверяет наличие узла в графе.
        
        Args:
            node_id: Идентификатор узла.
            
        Returns:
            True, если узел существует, иначе False.
        """
        pass
        
    @abstractmethod
    def has_edge(self, source: str, target: str, edge_type: str = "default") -> bool:
        """Проверяет наличие ребра в графе.
        
        Args:
            source: Идентификатор исходного узла.
            target: Идентификатор целевого узла.
            edge_type: Тип ребра.
            
        Returns:
            True, если ребро существует, иначе False.
        """
        pass
        
    @abstractmethod
    def get_all_nodes(self) -> List[str]:
        """Возвращает список всех узлов в графе.
        
        Returns:
            Список идентификаторов всех узлов.
        """
        pass
        
    @abstractmethod
    def get_all_edges(self) -> List[Tuple[str, str, str]]:
        """Возвращает список всех ребер в графе.
        
        Returns:
            Список кортежей (source, target, edge_type).
        """
        pass
```

### 8.3. Пример интерфейса INeuroSymbolicProcessor

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Union, Tuple, Set, Callable

class SymbolicRule:
    """Символическое правило для логического вывода."""
    
    def __init__(self, condition: str, action: str, weight: float = 1.0,
                confidence: float = 1.0, metadata: Optional[Dict[str, Any]] = None):
        self.condition = condition
        self.action = action
        self.weight = weight
        self.confidence = confidence
        self.metadata = metadata or {}
        self.id = None  # Будет установлен при добавлении в базу правил

class INeuroSymbolicProcessor(ABC):
    """Интерфейс для нейросимволического процессора.
    
    Этот интерфейс определяет методы для работы с правилами
    и выполнения логического вывода.
    
    Версия: 1.0.0
    """
    
    @abstractmethod
    def add_rule(self, rule: SymbolicRule) -> str:
        """Добавляет правило в базу знаний и возвращает его ID.
        
        Args:
            rule: Правило для добавления.
            
        Returns:
            Идентификатор добавленного правила.
        """
        pass
        
    @abstractmethod
    def execute_rule(self, rule_id: str, context: Dict[str, Any]) -> Any:
        """Выполняет указанное правило в заданном контексте.
        
        Args:
            rule_id: Идентификатор правила.
            context: Контекст выполнения.
            
        Returns:
            Результат выполнения правила.
        """
        pass
        
    @abstractmethod
    def derive(self, context: Dict[str, Any], depth: int = 1) -> List[Tuple[str, Any]]:
        """Производит логический вывод на основе правил и контекста.
        
        Args:
            context: Контекст для вывода.
            depth: Глубина вывода.
            
        Returns:
            Список кортежей (rule_id, result).
        """
        pass
        
    @abstractmethod
    def find_relevant_rules(self, context: Dict[str, Any]) -> List[str]:
        """Находит правила, относящиеся к заданному контексту.
        
        Args:
            context: Контекст для поиска правил.
            
        Returns:
            Список идентификаторов релевантных правил.
        """
        pass
        
    @abstractmethod
    def explain_derivation(self, result: Any) -> List[str]:
        """Объясняет, как был получен вывод.
        
        Args:
            result: Результат вывода.
            
        Returns:
            Список шагов вывода.
        """
        pass
        
    @abstractmethod
    def learn_rule(self, examples: List[Tuple[Dict[str, Any], Any]]) -> str:
        """Обучает новое правило на основе примеров.
        
        Args:
            examples: Список пар (контекст, результат).
            
        Returns:
            Идентификатор нового правила.
        """
        pass
        
    @abstractmethod
    def get_rule(self, rule_id: str) -> Optional[SymbolicRule]:
        """Возвращает правило по ID.
        
        Args:
            rule_id: Идентификатор правила.
            
        Returns:
            Правило или None, если правило не найдено.
        """
        pass
        
    @abstractmethod
    def update_rule(self, rule_id: str, **attributes) -> bool:
        """Обновляет атрибуты правила.
        
        Args:
            rule_id: Идентификатор правила.
            **attributes: Атрибуты для обновления.
            
        Returns:
            True, если правило было обновлено, иначе False.
        """
        pass
        
    @abstractmethod
    def remove_rule(self, rule_id: str) -> bool:
        """Удаляет правило из базы знаний.
        
        Args:
            rule_id: Идентификатор правила.
            
        Returns:
            True, если правило было удалено, иначе False.
        """
        pass
```

## 9. Процесс изменения интерфейсов

### 9.1. Процедура внесения изменений

1. **Предложение изменения**:
   - Создание запроса на изменение с описанием цели и обоснованием
   - Предоставление конкретного предложения изменения
   - Оценка влияния на существующие реализации

2. **Ревью**:
   - Ревью предложения командой разработчиков
   - Оценка соответствия принципам дизайна
   - Проверка обратной совместимости

3. **Реализация**:
   - Внесение изменений в интерфейс
   - Обновление реализаций
   - Обновление тестов

4. **Тестирование**:
   - Проверка работоспособности всех реализаций
   - Проверка обратной совместимости
   - Проверка корректности документации

5. **Выпуск**:
   - Обновление версии интерфейса
   - Обновление документации
   - Описание изменений в CHANGELOG

### 9.2. Шаблон запроса на изменение интерфейса

```
# Запрос на изменение интерфейса

## Интерфейс
Название интерфейса: IMemory

## Тип изменения
- [ ] Добавление нового метода
- [ ] Изменение существующего метода
- [ ] Устаревание метода
- [ ] Удаление метода
- [ ] Изменение структуры данных
- [ ] Другое (пожалуйста, опишите)

## Описание изменения
Краткое описание предлагаемого изменения.

## Обоснование
Почему это изменение необходимо?

## Влияние на существующие реализации
Как это изменение повлияет на существующие реализации?

## Обратная совместимость
Сохраняет ли изменение обратную совместимость?

## Предлагаемый код
```python
@abstractmethod
def new_method(self, param1: str) -> bool:
    """Описание нового метода.
    
    Args:
        param1: Описание параметра.
        
    Returns:
        Описание возвращаемого значения.
    """
    pass
```

## Тестовый код
```python
def test_new_method(memory: IMemory):
    assert memory.new_method("test") is True
```

## Дополнительная информация
Любая дополнительная информация, которая может быть полезна для ревью.
```

### 9.3. Версионирование и CHANGELOG

Пример CHANGELOG для интерфейса:

```
# Changelog for IMemory

## [2.0.0] - 2023-10-15
### Breaking Changes
- Изменена сигнатура метода `search`, добавлен параметр `filters`
- Удален устаревший метод `find`

### Added
- Добавлен метод `bulk_add` для эффективного добавления нескольких элементов
- Добавлен метод `statistics` для получения статистики по памяти

### Changed
- Метод `update` теперь возвращает обновленный элемент вместо булева значения

## [1.1.0] - 2023-08-20
### Added
- Добавлен метод `search_by_metadata` для поиска по метаданным
- Добавлен метод `consolidate` для консолидации памяти

### Deprecated
- Метод `find` помечен как устаревший, вместо него следует использовать `search`

## [1.0.0] - 2023-07-01
### Added
- Первая стабильная версия интерфейса
- Основные методы: `add`, `get`, `search`, `update`, `remove`, `clear`, `size`
```

## 10. Заключение

### 10.1. Основные принципы

1. **Интерфейсы превыше реализаций**: Всегда программируйте на уровне интерфейсов, а не конкретных реализаций.
2. **Малые, сфокусированные интерфейсы**: Интерфейсы должны быть минимальными и иметь четкую ответственность.
3. **Стабильность**: Изменения в интерфейсах должны быть обоснованными и минимальными.
4. **Документирование**: Каждый интерфейс и метод должны быть подробно документированы.
5. **Типизация**: Используйте аннотации типов для всех методов.
6. **Контракты**: Четко определяйте пред- и постусловия для методов.
7. **Тестирование**: Разрабатывайте тесты для проверки соответствия реализаций интерфейсам.

### 10.2. Контрольный список

Перед добавлением или изменением интерфейса проверьте следующие пункты:

- [ ] Интерфейс имеет четкое назначение и ответственность
- [ ] Методы интерфейса имеют ясные и минимальные сигнатуры
- [ ] Все методы имеют подробную документацию
- [ ] Все методы имеют полные аннотации типов
- [ ] Определены пред- и постусловия для методов
- [ ] Созданы тесты для проверки соответствия реализаций
- [ ] Сохранена обратная совместимость (для изменений)
- [ ] Обновлена версия интерфейса согласно семантическому версионированию
- [ ] Изменения описаны в CHANGELOG

### 10.3. Ресурсы и инструменты

1. **Инструменты для проверки типов**:
   - mypy: Статический анализ типов
   - PyRight: Альтернативный статический анализатор типов

2. **Инструменты для проверки документации**:
   - pydocstyle: Проверка соответствия документации стандартам
   - Sphinx: Генерация документации из docstrings

3. **Инструменты для тестирования**:
   - pytest: Фреймворк для тестирования
   - hypothesis: Генерация тестовых случаев
   - mypy-pytest: Интеграция mypy и pytest

4. **Шаблоны и примеры**:
   - example_interfaces/: Каталог с примерами интерфейсов
   - interface_templates/: Шаблоны для создания новых интерфейсов
   - test_templates/: Шаблоны для тестирования интерфейсов

Следование этим рекомендациям и использование предоставленных инструментов поможет создать чистую, понятную и поддерживаемую архитектуру системы на основе интерфейсов.
